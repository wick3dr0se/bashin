#!/bin/bash
# see usage in test.sh

4BIT() { # ANSI escape color codes
	local bg_clr fg_clr fx
	declare -A bg_clr fg_clr fx
bg_clr=(
[black]=40	[bright_black]=100
[red]=41	[bright_red]=101
[green]=42	[bright_green]=102
[yellow]=43	[bright_yellow]=103
[blue]=44	[bright_blue]=104
[purple]=45	[bright_purple]=105
[light-blue]=46	[bright_light_blue]=106
[white]=47	[bright_white]=107
)
fg_clr=(
[black]=30	[bright_black]=90
[red]=31	[bright_red]=91
[green]=32	[bright_green]=92
[yellow]=33	[bright_yellow]=93
[blue]=34	[bright_blue]=94
[purple]=35	[bright_purple]=95
[light-blue]=36	[bright_light_blue]=96
[white]=37	[bright_white]=97
)
fx=(
[bold]=1
[dim]=2
[italic]=3
[underline]=4
[blink]=5
[fast-blink]=6
[reverse]=7
[hidden]=8
[strikeout]=9
)

	for i in ${!fg_clr[@]} ${!bg_clr[@]} ${!fx[@]} ; do
		case $i in
			$2) fg_clr="${fg_clr[$i]}" ;;
			$3) [[ $4 ]] && bg_clr="${bg_clr[$i]};" || fx="${fx[$i]};" ;;
			$4) fx="${fx[$i]};" ;;
		esac
	done
	printf '\e[%s%s%sm%s\e[0m\n' "$fx" "$bg_clr" "$fg_clr" "$1"
}

ANSI() {
	local cursor val val2 erase
	
	IFS=- read x val val2 <<<$1

	declare -A cursor erase
cursor=(
[home]='\e[H'
[position]="\e[${val};${val2}H"
[up]="\e[${val}A"
[down]="\e[${val}B"
[right]="\e[${val}C"
[left]="\e[${val}D"
[^down]="\e[${val}E"
[^up]="\e[${val}F"
[col]="\e[${val}G"
[cursor]='\e[6n'
[up-scroll]='\M'
[save]='\7'
[restore]='\8'
)
erase=(
[del_cursor]='\e[J'
[del_cursor-start]='\e[1J'
[del_screen]='\e[2J'
[del_saved]='\e[3J'
[del_line]='\e[K'
[del_line-start]='\e[1K'
[del_line-clear]='\e[2K'
)
	
	for i in "${!cursor[@]}" "${!erase[@]}" ; do
		case $i in
			${1/-*}) cursor="${cursor[$i]}" ;;
			$2) erase="${erase[$i]}" ;;
		esac
	done
	
	printf "$cursor$erase"
}

ABSOLUTE_PATH() { # absolute path to script
	local var
	[[ $1 ]] && var="/${1}" || var=
	[[ ${0%/*} == ${0##*/} ]] && echo "$var" || echo "${0%/*}${var}"
}

RANDOM_ELEMENT() { # random element from array
	local var
	var=($@)
	echo "${var[RANDOM%${#var[@]}]}"
}

UNIQUE_ELEMENT() { # get unique elements from specified arrays
	local i
	for i in "${arr1[@]}" ; do	
		var1+=$i-
	done

	for i in "${arr2[@]}" ; do
		var2+=$i-
	done

	for i in "${arr1[@]}" "${arr2[@]}" ; do
		[[ $var1 =~ $i- ]] || printf '%s ' "$i"
		[[ $var2 =~ $i- ]] || printf '%s ' "$i"
	done
	echo
}

INCREMENT() { # increment by specification
	local n e i
	IFS='-+' read n e i <<<$1

	until [[ $n -ge $e ]] ; do
		((n+=$i))
		printf '%s ' "$n"
	done
	echo
}

RAINBOW() { # output characters in a rainbow pattern
	local i n
        i=1
	while read -N1 n ; do
		[[ $i -le 6 ]] && ((i++))
		[[ $i == 7 ]] && i=1
		[[ $n == ' ' ]] && i=$((i-1))
		printf '\e[1;3%sm%s\e[0m' "$i" "$n"
	done <<<$@
}
